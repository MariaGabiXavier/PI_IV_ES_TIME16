<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Chatbot â€” GetGreen </title>
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@300;400;600&family=Playfair+Display:wght@400;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="modal.css">
</head>
<body>
  
  <div id="modalOverlay" class="overlay" aria-hidden="true">
    <div class="modal" role="dialog" aria-modal="true" aria-labelledby="modalTitle">
      <button class="close" id="closeModal" aria-label="Fechar">Ã—</button>
      <h2 id="modalTitle">Chatbot GetGreen</h2>

      <div id="chatContainer" class="chat-container">
        <div id="chatArea" class="chat-area" aria-live="polite"></div>

        <div id="optionsContainer" class="options"></div>

        <div class="inputRow">
          <input id="manualInput" placeholder="Enviar mensagem (opcional)" autocomplete="off" />
          <button id="sendManual" class="submit-btn" style="width:120px;margin-left:8px">Enviar</button>
        </div>
      </div>
    </div>
  </div>

  <script>
    
    const open = document.getElementById('openModal');
    const overlay = document.getElementById('modalOverlay');
    const close = document.getElementById('closeModal');
    const form = document.getElementById('coletaForm');

    function showModal() {
      if (!overlay) return;
      overlay.style.display = 'flex';
      overlay.setAttribute('aria-hidden', 'false');
      // foco no input manual se existir, senÃ£o tenta o primeiro input do form
      const manual = document.getElementById('manualInput');
      if (manual) {
        // pequeno timeout garante que o elemento esteja interativo no DOM
        setTimeout(() => manual.focus(), 10);
        return;
      }
      const first = form && form.querySelector('input[name="responsavel"]');
      if (first) first.focus();
    }
    function hideModal() {
      if (!overlay) return;
      overlay.style.display = 'none';
      overlay.setAttribute('aria-hidden', 'true');
    }

    if (open) {
      open.addEventListener('click', (e) => { e.preventDefault(); showModal(); });
    }
    if (close) {
      close.addEventListener('click', hideModal);
    }
    if (overlay) {
      overlay.addEventListener('click', (e) => { if (e.target === overlay) hideModal(); });
    }

    try {
      const params = new URLSearchParams(window.location.search);
      if (params.get('open') === '1') showModal();
    } catch (e) { }

      const WS_URL = 'ws://localhost:8080';
      let ws = null;
      let reconnectTimer = null;

      const chatArea = document.getElementById('chatArea');
      const opts = document.getElementById('optionsContainer');
      const manualInput = document.getElementById('manualInput');
      const sendManual = document.getElementById('sendManual');

      function appendMessage(text, who) {
        const el = document.createElement('div');
        el.className = 'msg ' + (who === 'user' ? 'user' : 'server');
        el.textContent = text;
        chatArea.appendChild(el);
        chatArea.scrollTop = chatArea.scrollHeight;
      }

      function connectWS() {
        if (ws && (ws.readyState === WebSocket.OPEN || ws.readyState === WebSocket.CONNECTING)) return;
        ws = new WebSocket(WS_URL);
        ws.addEventListener('open', () => {
          appendMessage('Conectado ao adaptador.', 'user');
        });

        ws.addEventListener('message', (evt) => {
          let obj = null;
          try { obj = JSON.parse(evt.data); } catch (e) { console.warn('Invalid adapter message', evt.data); return; }
          if (obj.type === 'RESP' || obj.type === 'MSG') {
            const text = obj.payload || '';
            if (text.toLowerCase().includes('bem-vindo') || text.toLowerCase().includes('0 - sair')) {
              renderOptions(text);
              appendMessage('Menu recebido.', 'user');
            } else {
              appendMessage(text, 'server');
            }
          } else if (obj.type === 'DES') {
            appendMessage('Servidor estÃ¡ desligando.', 'server');
          } else if (obj.type === 'ERROR') {
            appendMessage('Erro: ' + obj.payload, 'server');
          }
        });

        ws.addEventListener('close', () => {
          appendMessage('ConexÃ£o com adaptador fechada.', 'user');
          // try reconnect later
          if (!reconnectTimer) reconnectTimer = setTimeout(() => { reconnectTimer = null; connectWS(); }, 2000);
        });

        ws.addEventListener('error', (e) => {
          console.error('WS error', e);
        });
      }

      // ðŸŒ¿ Lista global com as opÃ§Ãµes atuais do menu
let currentOptions = [];

// ===============================
// Renderiza as opÃ§Ãµes do menu
// ===============================
function renderOptions(menuText) {
  opts.innerHTML = '';
  currentOptions = []; // limpa opÃ§Ãµes anteriores

  const lines = menuText.split('\n');
  for (const line of lines) {
    const m = line.match(/^\s*(\d+)\s*-\s*(.+)$/);
    if (m) {
      const num = m[1];
      const label = m[2];
      currentOptions.push({ num, label }); // salva opÃ§Ã£o para busca

      const btn = document.createElement('button');
      btn.textContent = `${num} â€” ${label}`;
      btn.className = 'option-btn';
      btn.addEventListener('click', () => {
        if (!ws || ws.readyState !== WebSocket.OPEN) { 
          appendMessage('Adaptador indisponÃ­vel', 'user'); 
          return; 
        }
        ws.send(JSON.stringify({ type: 'PED', payload: num }));
        appendMessage('VocÃª: ' + label, 'user');
      });
      opts.appendChild(btn);
    }
  }
}

// ===============================
// Envia mensagens manuais (campo de texto)
// ===============================
sendManual.addEventListener('click', sendMessageManual);
manualInput.addEventListener('keydown', (e) => {
  if (e.key === 'Enter') sendMessageManual();
});

function sendMessageManual() {
  const txt = manualInput.value.trim();
  if (!txt) return;
  if (!ws || ws.readyState !== WebSocket.OPEN) { 
    appendMessage('Adaptador indisponÃ­vel', 'user'); 
    return; 
  }

  // Caso o usuÃ¡rio digite apenas um nÃºmero â†’ envia direto como PED
  if (/^\d+$/.test(txt)) {
    ws.send(JSON.stringify({ type: 'PED', payload: txt }));
    appendMessage('VocÃª: ' + txt, 'user');
    manualInput.value = '';
    return;
  }

  // Caso digite texto â†’ tenta identificar a opÃ§Ã£o correspondente
  const userLower = txt.toLowerCase();

  // busca por palavra inicial (ex: "agendar" em "1 - Agendar coleta")
  const found =
    currentOptions.find(opt =>
      userLower.includes(opt.label.toLowerCase().split(' ')[0])
    ) ||
    // ou busca se o texto do usuÃ¡rio aparece dentro do rÃ³tulo
    currentOptions.find(opt =>
      opt.label.toLowerCase().includes(userLower)
    );

  if (found) {
    ws.send(JSON.stringify({ type: 'PED', payload: found.num }));
    appendMessage('VocÃª (interpretei como): ' + found.label, 'user');
  } else {
    appendMessage('Por favor, responda com o nÃºmero da opÃ§Ã£o (ex: 1, 2, 0).', 'server');
  }

  manualInput.value = '';
}



      // inicializa
      connectWS();

      // Inicia escondido
      hideModal();
  </script>
</body>
</html>
